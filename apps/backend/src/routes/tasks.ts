import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { z } from 'zod';
import multer from 'multer';
import path from 'path';
import fs from 'fs';

const router = Router();
const prisma = new PrismaClient();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../../uploads/tasks');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage });

// Validation schemas
const createTaskSchema = z.object({
  title: z.string().min(1),
  description: z.string().optional(),
  status: z.enum(['todo', 'in_progress', 'done', 'overdue', 'cancelled']).default('todo'),
  priority: z.enum(['high', 'medium', 'low']).default('medium'),
  deadline: z.string().datetime().optional().nullable(),
  autoGenerated: z.boolean().optional().default(false),
  projectId: z.string().optional().nullable(),
  experimentId: z.string().optional().nullable(),
  protocolId: z.string().optional().nullable(),
  noteId: z.string().optional().nullable(),
  isRecurring: z.boolean().optional().default(false),
  recurringPattern: z.string().optional().nullable(), // JSON string
  estimatedHours: z.number().optional().nullable(),
  dependsOnId: z.string().optional().nullable(),
  templateId: z.string().optional().nullable(),
  tags: z.string().optional().nullable(), // JSON array
  metadata: z.string().optional().nullable(), // JSON
});

const updateTaskSchema = z.object({
  title: z.string().min(1).optional(),
  description: z.string().optional(),
  status: z.enum(['todo', 'in_progress', 'done', 'overdue', 'cancelled']).optional(),
  priority: z.enum(['high', 'medium', 'low']).optional(),
  deadline: z.string().datetime().optional().nullable(),
  completedAt: z.string().datetime().optional().nullable(),
  autoGenerated: z.boolean().optional(),
  experimentId: z.string().optional().nullable(),
  protocolId: z.string().optional().nullable(),
  noteId: z.string().optional().nullable(),
  isRecurring: z.boolean().optional(),
  recurringPattern: z.string().optional().nullable(),
  estimatedHours: z.number().optional().nullable(),
  actualHours: z.number().optional().nullable(),
  dependsOnId: z.string().optional().nullable(),
  templateId: z.string().optional().nullable(),
  tags: z.string().optional().nullable(),
  metadata: z.string().optional().nullable(),
});

const timeEntrySchema = z.object({
  startTime: z.string().datetime(),
  endTime: z.string().datetime().optional().nullable(),
  description: z.string().optional(),
});

const commentSchema = z.object({
  content: z.string().min(1),
  author: z.string().min(1),
});

const notificationSchema = z.object({
  type: z.enum(['reminder', 'overdue', 'due_soon', 'completed']),
  message: z.string().min(1),
  scheduledFor: z.string().datetime(),
});

// Get all tasks with advanced filtering
router.get('/', async (req, res) => {
  try {
    const {
      status,
      priority,
      projectId,
      experimentId,
      protocolId,
      noteId,
      isRecurring,
      overdue,
      dueSoon,
      search,
      tags,
      page = 1,
      limit = 50,
      sortBy = 'createdAt',
      sortOrder = 'desc'
    } = req.query;

    const where: any = {};
    const now = new Date();

    // Status filter
    if (status) {
      where.status = status;
    }

    // Priority filter
    if (priority) {
      where.priority = priority;
    }

    // Project filter
    if (projectId) {
      where.projectId = projectId;
    }

    // Experiment filter
    if (experimentId) {
      where.experimentId = experimentId;
    }

    // Protocol filter
    if (protocolId) {
      where.protocolId = protocolId;
    }

    // Note filter
    if (noteId) {
      where.noteId = noteId;
    }

    // Recurring filter
    if (isRecurring !== undefined) {
      where.isRecurring = isRecurring === 'true';
    }

    // Overdue filter
    if (overdue === 'true') {
      where.deadline = { lt: now };
      where.status = { not: 'done' };
    }

    // Due soon filter (next 7 days)
    if (dueSoon === 'true') {
      const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
      where.deadline = { gte: now, lte: nextWeek };
      where.status = { not: 'done' };
    }

    // Search filter
    if (search) {
      where.OR = [
        { title: { contains: search as string } },
        { description: { contains: search as string } },
      ];
    }

    // Tags filter
    if (tags) {
      where.tags = { contains: tags as string };
    }

    const skip = (parseInt(page as string) - 1) * parseInt(limit as string);
    const take = parseInt(limit as string);

    const [tasks, total] = await Promise.all([
      prisma.task.findMany({
        where,
        include: {
          project: true,
          experiment: true,
          protocol: true,
          note: true,
          template: true,
          comments: {
            orderBy: { createdAt: 'desc' }
          },
          attachments: {
            orderBy: { uploadedAt: 'desc' }
          },
          timeEntries: {
            orderBy: { startTime: 'desc' }
          }
        },
        orderBy: { [sortBy as string]: sortOrder },
        skip,
        take,
      }),
      prisma.task.count({ where })
    ]);

    // Calculate total time spent for each task
    const tasksWithTime = tasks.map(task => {
      const totalTimeSpent = task.timeEntries?.reduce((total, entry) => {
        if (entry.endTime) {
          const start = new Date(entry.startTime);
          const end = new Date(entry.endTime);
          return total + Math.round((end.getTime() - start.getTime()) / 60000); // minutes
        }
        return total;
      }, 0) || 0;

      return {
        ...task,
        totalTimeSpent
      };
    });

    res.json({
      tasks: tasksWithTime,
      pagination: {
        page: parseInt(page as string),
        limit: parseInt(limit as string),
        total,
        pages: Math.ceil(total / parseInt(limit as string))
      }
    });
  } catch (error) {
    console.error('Get tasks error:', error);
    res.status(500).json({ error: 'Failed to get tasks' });
  }
});

// Get tasks by project
router.get('/project/:projectId', async (req, res) => {
  try {
    const { projectId } = req.params;
    const tasks = await prisma.task.findMany({
      where: { projectId },
      include: {
        experiment: true,
        note: true,
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(tasks);
  } catch (error) {
    console.error('Get tasks by project error:', error);
    res.status(500).json({ error: 'Failed to get tasks by project' });
  }
});

// Get tasks by experiment
router.get('/experiment/:experimentId', async (req, res) => {
  try {
    const { experimentId } = req.params;
    const tasks = await prisma.task.findMany({
      where: { experimentId },
      include: {
        project: true,
        note: true,
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(tasks);
  } catch (error) {
    console.error('Get tasks by experiment error:', error);
    res.status(500).json({ error: 'Failed to get tasks by experiment' });
  }
});

// Get overdue tasks
router.get('/overdue', async (req, res) => {
  try {
    const now = new Date();
    const tasks = await prisma.task.findMany({
      where: {
        deadline: { lt: now },
        status: { not: 'done' },
      },
      include: {
        project: true,
        experiment: true,
      },
      orderBy: { deadline: 'asc' },
    });
    res.json(tasks);
  } catch (error) {
    console.error('Get overdue tasks error:', error);
    res.status(500).json({ error: 'Failed to get overdue tasks' });
  }
});

// Get task statistics
router.get('/stats', async (req, res) => {
  try {
    const [total, todo, inProgress, done, overdue] = await Promise.all([
      prisma.task.count(),
      prisma.task.count({ where: { status: 'todo' } }),
      prisma.task.count({ where: { status: 'in_progress' } }),
      prisma.task.count({ where: { status: 'done' } }),
      prisma.task.count({
        where: {
          deadline: { lt: new Date() },
          status: { not: 'done' },
        }
      })
    ]);

    res.json({
      total,
      todo,
      inProgress,
      done,
      overdue,
      completionRate: total > 0 ? (done / total) * 100 : 0
    });
  } catch (error) {
    console.error('Get task stats error:', error);
    res.status(500).json({ error: 'Failed to get task statistics' });
  }
});

// Create a task
router.post('/', async (req, res) => {
  try {
    const validated = createTaskSchema.parse(req.body);
    const task = await prisma.task.create({
      data: validated,
      include: {
        project: true,
        experiment: true,
        note: true,
      }
    });
    res.status(201).json(task);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation error', details: error.errors });
    }
    console.error('Create task error:', error);
    res.status(500).json({ error: 'Failed to create task' });
  }
});

// Update a task
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const validated = updateTaskSchema.parse(req.body);
    const task = await prisma.task.update({
      where: { id },
      data: validated,
      include: {
        project: true,
        experiment: true,
        note: true,
        dependsOn: true,
        dependentTasks: true,
      }
    });
    res.json(task);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation error', details: error.errors });
    }
    console.error('Update task error:', error);
    res.status(500).json({ error: 'Failed to update task' });
  }
});

// Delete a task
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.task.delete({ where: { id } });
    res.json({ success: true });
  } catch (error) {
    console.error('Delete task error:', error);
    res.status(500).json({ error: 'Failed to delete task' });
  }
});

// Bulk operations
router.post('/bulk', async (req, res) => {
  try {
    const { action, taskIds, data } = req.body;
    
    if (!taskIds || !Array.isArray(taskIds) || taskIds.length === 0) {
      return res.status(400).json({ error: 'Task IDs are required' });
    }

    switch (action) {
      case 'update':
        await prisma.task.updateMany({
          where: { id: { in: taskIds } },
          data: data
        });
        break;
      case 'delete':
        await prisma.task.deleteMany({
          where: { id: { in: taskIds } }
        });
        break;
      case 'complete':
        await prisma.task.updateMany({
          where: { id: { in: taskIds } },
          data: { status: 'done', completedAt: new Date() }
        });
        break;
      default:
        return res.status(400).json({ error: 'Invalid action' });
    }

    res.json({ success: true });
  } catch (error) {
    console.error('Bulk operation error:', error);
    res.status(500).json({ error: 'Failed to perform bulk operation' });
  }
});

// Time tracking endpoints
router.post('/:id/time-entries', async (req, res) => {
  try {
    const { id } = req.params;
    const validated = timeEntrySchema.parse(req.body);
    
    const timeEntry = await prisma.taskTimeEntry.create({
      data: {
        ...validated,
        taskId: id
      }
    });

    // Update actual hours on task
    const task = await prisma.task.findUnique({
      where: { id },
      include: { timeEntries: true }
    });

    if (task) {
      const totalHours = task.timeEntries.reduce((sum, entry) => {
        if (entry.endTime) {
          const duration = (new Date(entry.endTime).getTime() - new Date(entry.startTime).getTime()) / (1000 * 60 * 60);
          return sum + duration;
        }
        return sum;
      }, 0);

      await prisma.task.update({
        where: { id },
        data: { actualHours: totalHours }
      });
    }

    res.status(201).json(timeEntry);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation error', details: error.errors });
    }
    console.error('Create time entry error:', error);
    res.status(500).json({ error: 'Failed to create time entry' });
  }
});

// Comments endpoints
router.post('/:id/comments', async (req, res) => {
  try {
    const { id } = req.params;
    const validated = commentSchema.parse(req.body);
    
    const comment = await prisma.taskComment.create({
      data: {
        ...validated,
        taskId: id
      }
    });
    res.status(201).json(comment);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation error', details: error.errors });
    }
    console.error('Create comment error:', error);
    res.status(500).json({ error: 'Failed to create comment' });
  }
});

router.get('/:id/comments', async (req, res) => {
  try {
    const { id } = req.params;
    const comments = await prisma.taskComment.findMany({
      where: { taskId: id },
      orderBy: { createdAt: 'desc' }
    });
    res.json(comments);
  } catch (error) {
    console.error('Get comments error:', error);
    res.status(500).json({ error: 'Failed to get comments' });
  }
});

// Attachments endpoints
router.post('/:id/attachments', upload.single('file'), async (req, res) => {
  try {
    const { id } = req.params;
    const file = req.file;

    if (!file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const attachment = await prisma.taskAttachment.create({
      data: {
        taskId: id,
        fileName: file.originalname,
        filePath: file.path,
        fileSize: file.size,
        mimeType: file.mimetype,
      }
    });
    res.status(201).json(attachment);
  } catch (error) {
    console.error('Upload attachment error:', error);
    res.status(500).json({ error: 'Failed to upload attachment' });
  }
});

router.get('/:id/attachments', async (req, res) => {
  try {
    const { id } = req.params;
    const attachments = await prisma.taskAttachment.findMany({
      where: { taskId: id },
      orderBy: { uploadedAt: 'desc' }
    });
    res.json(attachments);
  } catch (error) {
    console.error('Get attachments error:', error);
    res.status(500).json({ error: 'Failed to get attachments' });
  }
});

// Notifications endpoints
router.post('/:id/notifications', async (req, res) => {
  try {
    const { id } = req.params;
    const validated = notificationSchema.parse(req.body);
    
    const notification = await prisma.taskNotification.create({
      data: {
        ...validated,
        taskId: id
      }
    });
    res.status(201).json(notification);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation error', details: error.errors });
    }
    console.error('Create notification error:', error);
    res.status(500).json({ error: 'Failed to create notification' });
  }
});

// Mark notification as read
router.put('/notifications/:notificationId/read', async (req, res) => {
  try {
    const { notificationId } = req.params;
    const notification = await prisma.taskNotification.update({
      where: { id: notificationId },
      data: { isRead: true }
    });
    res.json(notification);
  } catch (error) {
    console.error('Mark notification read error:', error);
    res.status(500).json({ error: 'Failed to mark notification as read' });
  }
});

// Delete comment
router.delete('/comments/:commentId', async (req, res) => {
  try {
    const { commentId } = req.params;
    await prisma.taskComment.delete({
      where: { id: commentId }
    });
    res.json({ success: true });
  } catch (error) {
    console.error('Delete comment error:', error);
    res.status(500).json({ error: 'Failed to delete comment' });
  }
});

// Delete time entry
router.delete('/time-entries/:timeEntryId', async (req, res) => {
  try {
    const { timeEntryId } = req.params;
    await prisma.taskTimeEntry.delete({
      where: { id: timeEntryId }
    });
    res.json({ success: true });
  } catch (error) {
    console.error('Delete time entry error:', error);
    res.status(500).json({ error: 'Failed to delete time entry' });
  }
});

// Delete attachment
router.delete('/attachments/:attachmentId', async (req, res) => {
  try {
    const { attachmentId } = req.params;
    const attachment = await prisma.taskAttachment.findUnique({
      where: { id: attachmentId }
    });
    
    if (!attachment) {
      return res.status(404).json({ error: 'Attachment not found' });
    }
    
    // Delete file from filesystem
    if (fs.existsSync(attachment.filePath)) {
      fs.unlinkSync(attachment.filePath);
    }
    
    // Delete from database
    await prisma.taskAttachment.delete({
      where: { id: attachmentId }
    });
    
    res.json({ success: true });
  } catch (error) {
    console.error('Delete attachment error:', error);
    res.status(500).json({ error: 'Failed to delete attachment' });
  }
});

// Download attachment
router.get('/attachments/:attachmentId/download', async (req, res) => {
  try {
    const { attachmentId } = req.params;
    const attachment = await prisma.taskAttachment.findUnique({
      where: { id: attachmentId }
    });
    
    if (!attachment) {
      return res.status(404).json({ error: 'Attachment not found' });
    }
    
    if (!fs.existsSync(attachment.filePath)) {
      return res.status(404).json({ error: 'File not found on disk' });
    }
    
    res.download(attachment.filePath, attachment.fileName);
  } catch (error) {
    console.error('Download attachment error:', error);
    res.status(500).json({ error: 'Failed to download attachment' });
  }
});

export default router; 